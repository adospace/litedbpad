<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LiteDB</name>
    </assembly>
    <members>
        <member name="M:LiteDB.LiteCollection`1.Count">
            <summary>
            Get document count using property on collection.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Count(LiteDB.Query)">
            <summary>
            Count documents matching a query. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Count(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Count documents matching a query. This method does not deserialize any documents. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.LongCount">
            <summary>
            Get document count using property on collection.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.LongCount(LiteDB.Query)">
            <summary>
            Count documents matching a query. This method does not deserialize any documents. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.LongCount(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Count documents matching a query. This method does not deserialize any documents. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Exists(LiteDB.Query)">
            <summary>
            Returns true if query returns any document. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Exists(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Returns true if query returns any document. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Min(System.String)">
            <summary>
            Returns the first/min value from a index field
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Min">
            <summary>
            Returns the first/min _id field
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Min``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Returns the first/min field using a linq expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Max(System.String)">
            <summary>
            Returns the last/max value from a index field
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Max">
            <summary>
            Returns the last/max _id field
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Max``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Returns the last/max field using a linq expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Delete(LiteDB.Query)">
            <summary>
            Remove all document based on a Query object. Returns removed document counts
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Delete(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Remove all document based on a LINQ query. Returns removed document counts
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Delete(LiteDB.BsonValue)">
            <summary>
            Remove an document in collection using Document Id - returns false if not found document
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Find(LiteDB.Query,System.Int32,System.Int32)">
            <summary>
            Find documents inside a collection using Query object.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Find(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.Int32,System.Int32)">
            <summary>
            Find documents inside a collection using Linq expression. Must have indexes in linq expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindById(LiteDB.BsonValue)">
            <summary>
            Find a document using Document Id. Returns null if not found.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindOne(LiteDB.Query)">
            <summary>
            Find the first document using Query object. Returns null if not found. Must have index on query expression.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindOne(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Find the first document using Linq expression. Returns null if not found. Must have indexes on predicate.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindAll">
            <summary>
            Returns all documents inside collection order by _id index.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Run an include action in each document returned by Find(), FindById(), FindOne() and All() methods to load DbRef documents
            Returns a new Collection with this action included
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Include(System.String)">
            <summary>
            Run an include action in each document returned by Find(), FindById(), FindOne() and All() methods to load DbRef documents
            Returns a new Collection with this action included
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.EnsureIndex(System.String,System.Boolean)">
            <summary>
            Create a new permanent index in all documents inside this collections if index not exists already. Returns true if index was created or false if already exits
            </summary>
            <param name="field">Document field name (case sensitive)</param>
            <param name="unique">If is a unique index</param>
        </member>
        <member name="M:LiteDB.LiteCollection`1.EnsureIndex``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Create a new permanent index in all documents inside this collections if index not exists already.
            </summary>
            <param name="property">Property linq expression</param>
            <param name="unique">Create a unique values index?</param>
        </member>
        <member name="M:LiteDB.LiteCollection`1.IndexFactory(System.String)">
            <summary>
            Internal ensure index for auto-create index when needed
            It's override LiteEngine define index because in LiteDatabase we have index definition in BsonMapper
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.GetIndexes">
            <summary>
            Returns all indexes information
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.DropIndex(System.String)">
            <summary>
            Drop index and release slot for another index
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Insert(`0)">
            <summary>
            Insert a new document to this collection. Document Id must be a new value in collection - Returns document Id
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Insert(LiteDB.BsonValue,`0)">
            <summary>
            Insert a new document to this collection using passed id value.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Insert(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert an array of new documents to this collection. Document Id must be a new value in collection. Can be set buffer size to commit at each N documents
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.GetBsonDocs(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Convert each T document in a BsonDocument, setting autoId for each one
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Upsert(`0)">
            <summary>
            Insert or Update a document in this collection.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Upsert(LiteDB.BsonValue,`0)">
            <summary>
            Insert or Update a document in this collection.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Upsert(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert or Update all documents
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Update(`0)">
            <summary>
            Update a document in this collection. Returns false if not found document in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Update(LiteDB.BsonValue,`0)">
            <summary>
            Update a document in this collection. Returns false if not found document in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Update(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Update all documents
            </summary>
        </member>
        <member name="P:LiteDB.LiteCollection`1.Name">
            <summary>
            Get collection name
            </summary>
        </member>
        <member name="P:LiteDB.LiteCollection`1.Visitor">
            <summary>
            Returns visitor resolver query only for internals implementations
            </summary>
        </member>
        <member name="T:LiteDB.LiteDatabase">
            <summary>
            The LiteDB database. Used for create a LiteDB instance and use all storage resources. It's the database connection
            </summary>
        </member>
        <member name="P:LiteDB.LiteDatabase.Log">
            <summary>
            Get logger class instance
            </summary>
        </member>
        <member name="P:LiteDB.LiteDatabase.Mapper">
            <summary>
            Get current instance of BsonMapper used in this database instance (can be BsonMapper.Global)
            </summary>
        </member>
        <member name="P:LiteDB.LiteDatabase.Engine">
            <summary>
            Get current database engine instance. Engine is lower data layer that works with BsonDocuments only (no mapper, no LINQ)
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(System.String,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using a connection string for file system database
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(LiteDB.ConnectionString,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using a connection string for file system database
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(System.IO.Stream,LiteDB.BsonMapper,System.String)">
            <summary>
            Starts LiteDB database using a Stream disk
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(LiteDB.IDiskService,LiteDB.BsonMapper,System.String,System.Nullable{System.TimeSpan},System.Int32,LiteDB.Logger)">
            <summary>
            Starts LiteDB database using a custom IDiskService with all parameters available
            </summary>
            <param name="diskService">Custom implementation of persist data layer</param>
            <param name="mapper">Instance of BsonMapper that map poco classes to document</param>
            <param name="password">Password to encrypt you datafile</param>
            <param name="timeout">Locker timeout for concurrent access</param>
            <param name="cacheSize">Max memory pages used before flush data in Journal file (when available)</param>
            <param name="log">Custom log implementation</param>
        </member>
        <member name="M:LiteDB.LiteDatabase.BeginTrans">
            <summary>
            Starts new transaction
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollection``1(System.String)">
            <summary>
            Get a collection using a entity class as strong typed document. If collection does not exits, create a new one.
            </summary>
            <param name="name">Collection name (case insensitive)</param>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollection``1">
            <summary>
            Get a collection using a name based on typeof(T).Name (BsonMapper.ResolveCollectionName function)
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollection(System.String)">
            <summary>
            Get a collection using a generic BsonDocument. If collection does not exits, create a new one.
            </summary>
            <param name="name">Collection name (case insensitive)</param>
        </member>
        <member name="P:LiteDB.LiteDatabase.FileStorage">
            <summary>
            Returns a special collection for storage files/stream inside datafile
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollectionNames">
            <summary>
            Get all collections name inside this database.
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.CollectionExists(System.String)">
            <summary>
            Checks if a collection exists on database. Collection name is case insensitive
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.DropCollection(System.String)">
            <summary>
            Drop a collection and all data + indexes
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.RenameCollection(System.String,System.String)">
            <summary>
            Rename a collection. Returns false if oldName does not exists or newName already exists
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.Shrink">
            <summary>
            Reduce disk size re-arranging unused spaces.
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.Shrink(System.String)">
            <summary>
            Reduce disk size re-arranging unused space. Can change password. If a temporary disk was not provided, use MemoryStream temp disk
            </summary>
        </member>
        <member name="T:LiteDB.StreamDiskService">
            <summary>
            Implement generic Stream disk service. Used for any read/write/seek stream
            No journal implemented
            </summary>
        </member>
        <member name="F:LiteDB.StreamDiskService.PAGE_TYPE_POSITION">
            <summary>
            Position, on page, about page type
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.ReadPage(System.UInt32)">
            <summary>
            Read page bytes from disk
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.WritePage(System.UInt32,System.Byte[])">
            <summary>
            Persist single page bytes to disk
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.SetLength(System.Int64)">
            <summary>
            Set datafile length
            </summary>
        </member>
        <member name="P:LiteDB.StreamDiskService.FileLength">
            <summary>
            Returns file length
            </summary>
        </member>
        <member name="P:LiteDB.StreamDiskService.IsExclusive">
            <summary>
            Single process only
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.WriteJournal(System.Collections.Generic.ICollection{System.Byte[]})">
            <summary>
            No journal implemented
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.ReadJournal">
            <summary>
            No journal implemented
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.ClearJournal">
            <summary>
            No journal implemented
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.Lock(LiteDB.LockState,System.TimeSpan)">
            <summary>
            No lock implemented
            </summary>
        </member>
        <member name="M:LiteDB.StreamDiskService.Unlock(LiteDB.LockState)">
            <summary>
            No lock implemented
            </summary>
        </member>
        <member name="T:LiteDB.LiteEngine">
            <summary>
            A public class that take care of all engine data structure access - itÂ´s basic implementation of a NoSql database
            Its isolated from complete solution - works on low level only (no linq, no poco... just Bson objects)
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Upsert(System.String,LiteDB.BsonDocument)">
            <summary>
            Implement upsert command to documents in a collection. Calls update on all documents,
            then any documents not updated are then attempted to insert.
            This will have the side effect of throwing if duplicate items are attempted to be inserted. Returns true if document is inserted
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Upsert(System.String,System.Collections.Generic.IEnumerable{LiteDB.BsonDocument})">
            <summary>
            Implement upsert command to documents in a collection. Calls update on all documents,
            then any documents not updated are then attempted to insert.
            This will have the side effect of throwing if duplicate items are attempted to be inserted.
            </summary>
        </member>
        <member name="P:LiteDB.LiteEngine.TransactionCount">
            <summary>
            Get transaction stack count. If returns 0, there is no transaction.
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.BeginTrans">
            <summary>
            Starts a new transaction keeping all changed from now in memory only until Commit() be executed.
            Lock thread in write mode to not accept other transaction
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Commit">
            <summary>
            Persist in disk all changed from last BeginTrans()
            Returns true if real commit was done (false to nested commit only)
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Rollback">
            <summary>
            Discard all changes from last BeginTrans()
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Transaction``1(System.String,System.Boolean,System.Func{LiteDB.CollectionPage,``0})">
            <summary>
            Encapsulate all write transaction operation
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Shrink(System.String,LiteDB.IDiskService)">
            <summary>
            Reduce disk size re-arranging unused spaces. Can change password. If temporary disk was not provided, use MemoryStream temp disk
            </summary>
        </member>
        <member name="P:LiteDB.LiteEngine.Log">
            <summary>
            Get log instance for debug operations
            </summary>
        </member>
        <member name="P:LiteDB.LiteEngine.CacheSize">
            <summary>
            Get memory cache size limit. Works only with journal enabled (number in pages). If journal is disabled, pages in cache can exceed this limit. Default is 5000 pages
            </summary>
        </member>
        <member name="P:LiteDB.LiteEngine.CacheUsed">
            <summary>
            Get how many pages are on cache
            </summary>
        </member>
        <member name="P:LiteDB.LiteEngine.Timeout">
            <summary>
            Gets time waiting write lock operation before throw LiteException timeout
            </summary>
        </member>
        <member name="P:LiteDB.LiteEngine.Locker">
            <summary>
            Instance of locker control
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.#ctor(System.String,System.Boolean)">
            <summary>
            Initialize LiteEngine using default FileDiskService
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Initialize LiteEngine with password encryption
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.#ctor(System.IO.Stream,System.String)">
            <summary>
            Initialize LiteEngine using StreamDiskService
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.#ctor(LiteDB.IDiskService,System.String,System.Nullable{System.TimeSpan},System.Int32,LiteDB.Logger)">
            <summary>
            Initialize LiteEngine using custom disk service implementation and full engine options
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.InitializeServices">
            <summary>
            Create instances for all engine services
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.GetCollectionPage(System.String,System.Boolean)">
            <summary>
            Get the collection page only when needed. Gets from pager always to grantee that wil be the last (in case of clear cache will get a new one - pageID never changes)
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.CreateDatabase(System.IO.Stream,System.String)">
            <summary>
            Initialize new datafile with header page + lock reserved area zone
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Min(System.String,System.String)">
            <summary>
            Returns first value from an index (first is min value)
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Max(System.String,System.String)">
            <summary>
            Returns last value from an index (last is max value)
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Count(System.String,LiteDB.Query)">
            <summary>
            Count all nodes from a query execution - do not deserialize documents to count. If query is null, use Collection counter variable
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Exists(System.String,LiteDB.Query)">
            <summary>
            Check if has at least one node in a query execution - do not deserialize documents to check
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.GetCollectionNames">
            <summary>
            Returns all collection inside datafile
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.DropCollection(System.String)">
            <summary>
            Drop collection including all documents, indexes and extended pages
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.RenameCollection(System.String,System.String)">
            <summary>
            Rename a collection
            </summary>
        </member>
        <member name="P:LiteDB.LiteEngine.UserVersion">
            <summary>
            Get/Set User version internal database
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Delete(System.String,LiteDB.BsonValue)">
            <summary>
            Implement delete command based on _id value. Returns true if deleted
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Delete(System.String,LiteDB.Query)">
            <summary>
            Implements delete based on a query result
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Find(System.String,LiteDB.Query,System.Int32,System.Int32)">
            <summary>
            Find for documents in a collection using Query definition
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.FindIndex(System.String,LiteDB.Query,System.Int32,System.Int32)">
            <summary>
            Find index keys from collection. Do not retorn document, only key value
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.FindOne(System.String,LiteDB.Query)">
            <summary>
            Find first or default document based in collection based on Query filter
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.FindById(System.String,LiteDB.BsonValue)">
            <summary>
            Find first or default document based in _id field
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.FindAll(System.String)">
            <summary>
            Returns all documents inside collection order by _id index.
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.EnsureIndex(System.String,System.String,System.Boolean)">
            <summary>
            Create a new index (or do nothing if already exists) to a collection/field
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.DropIndex(System.String,System.String)">
            <summary>
            Drop an index from a collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.GetIndexes(System.String)">
            <summary>
            List all indexes inside a collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Insert(System.String,LiteDB.BsonDocument)">
            <summary>
            Implements insert documents in a collection - returns _id value
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Insert(System.String,System.Collections.Generic.IEnumerable{LiteDB.BsonDocument})">
            <summary>
            Implements insert documents in a collection - use a buffer to commit transaction in each buffer count
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.InsertDocument(LiteDB.CollectionPage,LiteDB.BsonDocument)">
            <summary>
            Internal implementation of insert a document
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Update(System.String,LiteDB.BsonDocument)">
            <summary>
            Implement update command to a document inside a collection. Returns true if document was updated
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Update(System.String,System.Collections.Generic.IEnumerable{LiteDB.BsonDocument})">
            <summary>
            Implement update command to a document inside a collection. Return number of documents updated
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.UpdateDocument(LiteDB.CollectionPage,LiteDB.BsonDocument)">
            <summary>
            Implement internal update document
            </summary>
        </member>
        <member name="M:LiteDB.LiteEngine.Upgrade(System.String,System.String,System.Boolean,System.Int32)">
            <summary>
            Upgrade datafile from v6 to new v7 format used in LiteDB 3
            </summary>
        </member>
        <member name="T:LiteDB.FileDiskService">
            <summary>
            Implement NTFS File disk
            </summary>
        </member>
        <member name="F:LiteDB.FileDiskService.PAGE_TYPE_POSITION">
            <summary>
            Position, on page, about page type
            </summary>
        </member>
        <member name="F:LiteDB.FileDiskService.LOCK_POSITION">
            <summary>
            Map lock positions
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.ReadPage(System.UInt32)">
            <summary>
            Read page bytes from disk
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.WritePage(System.UInt32,System.Byte[])">
            <summary>
            Persist single page bytes to disk
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.SetLength(System.Int64)">
            <summary>
            Set datafile length
            </summary>
        </member>
        <member name="P:LiteDB.FileDiskService.FileLength">
            <summary>
            Returns file length
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.WriteJournal(System.Collections.Generic.ICollection{System.Byte[]})">
            <summary>
            Write original bytes page in a journal file (in sequence) - if journal not exists, create.
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.ReadJournal">
            <summary>
            Read journal file returning IEnumerable of pages
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.ClearJournal">
            <summary>
            Clear journal file (set size to 0 length)
            </summary>
        </member>
        <member name="P:LiteDB.FileDiskService.IsExclusive">
            <summary>
            Indicate disk can be access by multiples processes or not
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.Lock(LiteDB.LockState,System.TimeSpan)">
            <summary>
            Implement datafile lock/unlock
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.Unlock(LiteDB.LockState)">
            <summary>
            Unlock datafile based on state
            </summary>
        </member>
        <member name="M:LiteDB.FileDiskService.CreateFileStream(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Create a new filestream. Can be synced over async task (netstandard)
            </summary>
        </member>
        <member name="M:LiteDB.IDiskService.Initialize(LiteDB.Logger,System.String)">
            <summary>
            Open data file (creating if doest exists) and validate header
            </summary>
        </member>
        <member name="M:LiteDB.IDiskService.ReadPage(System.UInt32)">
            <summary>
            Read a page from disk datafile
            </summary>
        </member>
        <member name="M:LiteDB.IDiskService.WritePage(System.UInt32,System.Byte[])">
            <summary>
            Write a page in disk datafile
            </summary>
        </member>
        <member name="M:LiteDB.IDiskService.SetLength(System.Int64)">
            <summary>
            Set datafile length before start writing in disk
            </summary>
        </member>
        <member name="P:LiteDB.IDiskService.FileLength">
            <summary>
            Gets file length in bytes
            </summary>
        </member>
        <member name="P:LiteDB.IDiskService.IsExclusive">
            <summary>
            Indicate that disk/instance are data access exclusive (no other process can access)
            </summary>
        </member>
        <member name="M:LiteDB.IDiskService.ReadJournal">
            <summary>
            Read journal file returning IEnumerable of pages
            </summary>
        </member>
        <member name="M:LiteDB.IDiskService.WriteJournal(System.Collections.Generic.ICollection{System.Byte[]})">
            <summary>
            Write original bytes page in a journal file (in sequence) - if journal not exists, create.
            </summary>
        </member>
        <member name="M:LiteDB.IDiskService.ClearJournal">
            <summary>
            Clear journal file
            </summary>
        </member>
        <member name="M:LiteDB.IDiskService.Lock(LiteDB.LockState,System.TimeSpan)">
            <summary>
            Lock datafile returning lock position
            </summary>
        </member>
        <member name="M:LiteDB.IDiskService.Unlock(LiteDB.LockState)">
            <summary>
            Unlock datafile based on last state
            </summary>
        </member>
        <member name="F:LiteDB.BasePage.PAGE_SIZE">
            <summary>
            The size of each page in disk - 4096 is NTFS default
            </summary>
        </member>
        <member name="F:LiteDB.BasePage.PAGE_HEADER_SIZE">
            <summary>
            This size is used bytes in header pages 17 bytes (+8 reserved to future use) = 25 bytes
            </summary>
        </member>
        <member name="F:LiteDB.BasePage.PAGE_AVAILABLE_BYTES">
            <summary>
            Bytes available to store data removing page header size - 4071 bytes
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.PageID">
            <summary>
            Represent page number - start in 0 with HeaderPage [4 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.PageType">
            <summary>
            Indicate the page type [1 byte] - Must be implemented for each page type
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.PrevPageID">
            <summary>
            Represent the previous page. Used for page-sequences - MaxValue represent that has NO previous page [4 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.NextPageID">
            <summary>
            Represent the next page. Used for page-sequences - MaxValue represent that has NO next page [4 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.ItemCount">
            <summary>
            Used for all pages to count items inside this page(bytes, nodes, blocks, ...) [2 bytes]
            Its Int32 but writes in UInt16
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.FreeBytes">
            <summary>
            Used to find a free page using only header search [used in FreeList] [2 bytes]
            Its Int32 but writes in UInt16
            Its updated when a page modify content length (add/remove items)
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.IsDirty">
            <summary>
            Indicate that this page is dirty (was modified) and must persist when committed [not-persistable]
            </summary>
        </member>
        <member name="P:LiteDB.BasePage.DiskData">
            <summary>
            This is the data when read first from disk - used to journal operations (IDiskService only will use)
            </summary>
        </member>
        <member name="M:LiteDB.BasePage.UpdateItemCount">
            <summary>
            Every page must implement this ItemCount + FreeBytes
            Must be called after Items are updates (insert/deletes) to keep variables ItemCount and FreeBytes synced
            </summary>
        </member>
        <member name="M:LiteDB.BasePage.GetSizeOfPages(System.UInt32)">
            <summary>
            Returns a size of specified number of pages
            </summary>
            <param name="pageCount">The page count</param>
        </member>
        <member name="M:LiteDB.BasePage.GetSizeOfPages(System.Int32)">
            <summary>
            Returns a size of specified number of pages
            </summary>
            <param name="pageCount">The page count</param>
        </member>
        <member name="M:LiteDB.BasePage.CreateInstance``1(System.UInt32)">
            <summary>
            Create a new instance of page based on T type
            </summary>
        </member>
        <member name="M:LiteDB.BasePage.CreateInstance(System.UInt32,LiteDB.PageType)">
            <summary>
            Create a new instance of page based on PageType
            </summary>
        </member>
        <member name="M:LiteDB.BasePage.ReadPage(System.Byte[])">
            <summary>
            Read a page with correct instance page object. Checks for pageType
            </summary>
        </member>
        <member name="M:LiteDB.BasePage.WritePage">
            <summary>
            Write a page to byte array
            </summary>
        </member>
        <member name="T:LiteDB.CollectionPage">
            <summary>
            Represents the collection page AND a collection item, because CollectionPage represent a Collection (1 page = 1 collection). All collections pages are linked with Prev/Next links
            </summary>
        </member>
        <member name="F:LiteDB.CollectionPage.MAX_COLLECTIONS_SIZE">
            <summary>
            Represent maximum bytes that all collections names can be used in header
            </summary>
        </member>
        <member name="P:LiteDB.CollectionPage.PageType">
            <summary>
            Page type = Collection
            </summary>
        </member>
        <member name="P:LiteDB.CollectionPage.CollectionName">
            <summary>
            Name of collection
            </summary>
        </member>
        <member name="F:LiteDB.CollectionPage.FreeDataPageID">
            <summary>
            Get a reference for the free list data page - its private list per collection - each DataPage contains only data for 1 collection (no mixing)
            Must to be a Field to be used as parameter reference
            </summary>
        </member>
        <member name="P:LiteDB.CollectionPage.DocumentCount">
            <summary>
            Get the number of documents inside this collection
            </summary>
        </member>
        <member name="P:LiteDB.CollectionPage.Indexes">
            <summary>
            Get all indexes from this collection - includes non-used indexes
            </summary>
        </member>
        <member name="M:LiteDB.CollectionPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="M:LiteDB.CollectionPage.GetFreeIndex">
            <summary>
            Returns first free index slot to be used
            </summary>
        </member>
        <member name="M:LiteDB.CollectionPage.GetIndex(System.String)">
            <summary>
            Get index from field name (index field name is case sensitive) - returns null if not found
            </summary>
        </member>
        <member name="P:LiteDB.CollectionPage.PK">
            <summary>
            Get primary key index (_id index)
            </summary>
        </member>
        <member name="M:LiteDB.CollectionPage.GetIndexes(System.Boolean)">
            <summary>
            Returns all used indexes
            </summary>
        </member>
        <member name="T:LiteDB.DataPage">
            <summary>
            The DataPage thats stores object data.
            </summary>
        </member>
        <member name="P:LiteDB.DataPage.PageType">
            <summary>
            Page type = Extend
            </summary>
        </member>
        <member name="F:LiteDB.DataPage.DATA_RESERVED_BYTES">
            <summary>
            If a Data Page has less that free space, it's considered full page for new items. Can be used only for update (DataPage) ~ 50% PAGE_AVAILABLE_BYTES
            This value is used for minimize
            </summary>
        </member>
        <member name="P:LiteDB.DataPage.DataBlocks">
            <summary>
            Returns all data blocks - Each block has one object
            </summary>
        </member>
        <member name="M:LiteDB.DataPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="T:LiteDB.EmptyPage">
            <summary>
            Represent a empty page (reused)
            </summary>
        </member>
        <member name="P:LiteDB.EmptyPage.PageType">
            <summary>
            Page type = Empty
            </summary>
        </member>
        <member name="M:LiteDB.EmptyPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="T:LiteDB.ExtendPage">
            <summary>
            Represent a extra data page that contains the object when is not possible store in DataPage (bigger then  PAGE_SIZE or on update has no more space on page)
            Can be used in sequence of pages to store big objects
            </summary>
        </member>
        <member name="P:LiteDB.ExtendPage.PageType">
            <summary>
            Page type = Extend
            </summary>
        </member>
        <member name="P:LiteDB.ExtendPage.Data">
            <summary>
            Represent the part or full of the object - if this page has NextPageID the object is bigger than this page
            </summary>
        </member>
        <member name="M:LiteDB.ExtendPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="P:LiteDB.HeaderPage.PageType">
            <summary>
            Page type = Header
            </summary>
        </member>
        <member name="F:LiteDB.HeaderPage.HEADER_INFO">
            <summary>
            Header info the validate that datafile is a LiteDB file (27 bytes)
            </summary>
        </member>
        <member name="F:LiteDB.HeaderPage.FILE_VERSION">
            <summary>
            Datafile specification version
            </summary>
        </member>
        <member name="P:LiteDB.HeaderPage.ChangeID">
            <summary>
            Last modified transaction. Used to detect when other process change datafile and cache are not valid anymore
            </summary>
        </member>
        <member name="F:LiteDB.HeaderPage.FreeEmptyPageID">
            <summary>
            Get/Set the pageID that start sequence with a complete empty pages (can be used as a new page)
            Must be a field to be used as "ref"
            </summary>
        </member>
        <member name="P:LiteDB.HeaderPage.LastPageID">
            <summary>
            Last created page - Used when there is no free page inside file
            </summary>
        </member>
        <member name="P:LiteDB.HeaderPage.UserVersion">
            <summary>
            Database user version [2 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.HeaderPage.Password">
            <summary>
            Password hash in SHA1 [20 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.HeaderPage.Salt">
            <summary>
            When using encryption, store salt for password
            </summary>
        </member>
        <member name="P:LiteDB.HeaderPage.CollectionPages">
            <summary>
            Get a dictionary with all collection pages with pageID link
            </summary>
        </member>
        <member name="M:LiteDB.HeaderPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="P:LiteDB.IndexPage.PageType">
            <summary>
            Page type = Index
            </summary>
        </member>
        <member name="F:LiteDB.IndexPage.INDEX_RESERVED_BYTES">
            <summary>
            If a Index Page has less that this free space, it's considered full page for new items.
            </summary>
        </member>
        <member name="M:LiteDB.IndexPage.UpdateItemCount">
            <summary>
            Update freebytes + items count
            </summary>
        </member>
        <member name="T:LiteDB.Query">
            <summary>
            Class helper to create query using indexes in database. All methods are statics.
            Queries can be executed in 2 ways: Index Seek (fast), Index Scan (good)
            </summary>
        </member>
        <member name="M:LiteDB.Query.IndexFactory(System.Action{System.String,System.String})">
            <summary>
            Set, only if not defined yet, a new factory to create index if nedded
            </summary>
        </member>
        <member name="F:LiteDB.Query.Ascending">
            <summary>
            Indicate when a query must execute in ascending order
            </summary>
        </member>
        <member name="F:LiteDB.Query.Descending">
            <summary>
            Indicate when a query must execute in descending order
            </summary>
        </member>
        <member name="M:LiteDB.Query.All(System.Int32)">
            <summary>
            Returns all documents using _id index order
            </summary>
        </member>
        <member name="M:LiteDB.Query.All(System.String,System.Int32)">
            <summary>
            Returns all documents using field index order
            </summary>
        </member>
        <member name="M:LiteDB.Query.EQ(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are equals to value (=)
            </summary>
        </member>
        <member name="M:LiteDB.Query.LT(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are less than value (&lt;)
            </summary>
        </member>
        <member name="M:LiteDB.Query.LTE(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are less than or equals value (&lt;=)
            </summary>
        </member>
        <member name="M:LiteDB.Query.GT(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all document that value are greater than value (&gt;)
            </summary>
        </member>
        <member name="M:LiteDB.Query.GTE(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are greater than or equals value (&gt;=)
            </summary>
        </member>
        <member name="M:LiteDB.Query.Between(System.String,LiteDB.BsonValue,LiteDB.BsonValue)">
            <summary>
            Returns all document that values are between "start" and "end" values (BETWEEN)
            </summary>
        </member>
        <member name="M:LiteDB.Query.StartsWith(System.String,System.String)">
            <summary>
            Returns all documents that starts with value (LIKE)
            </summary>
        </member>
        <member name="M:LiteDB.Query.Contains(System.String,System.String)">
            <summary>
            Returns all documents that contains value (CONTAINS)
            </summary>
        </member>
        <member name="M:LiteDB.Query.Not(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that are not equals to value (not equals)
            </summary>
        </member>
        <member name="M:LiteDB.Query.Not(LiteDB.Query,System.Int32)">
            <summary>
            Returns all documents that in query result (not result)
            </summary>
        </member>
        <member name="M:LiteDB.Query.In(System.String,LiteDB.BsonArray)">
            <summary>
            Returns all documents that has value in values list (IN)
            </summary>
        </member>
        <member name="M:LiteDB.Query.In(System.String,LiteDB.BsonValue[])">
            <summary>
            Returns all documents that has value in values list (IN)
            </summary>
        </member>
        <member name="M:LiteDB.Query.In(System.String,System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Returns all documents that has value in values list (IN)
            </summary>
        </member>
        <member name="M:LiteDB.Query.Where(System.String,System.Func{LiteDB.BsonValue,System.Boolean},System.Int32)">
            <summary>
            Apply a predicate function in an index result. Execute full index scan but it's faster then runs over deserialized document.
            </summary>
        </member>
        <member name="M:LiteDB.Query.And(LiteDB.Query,LiteDB.Query)">
            <summary>
            Returns document that exists in BOTH queries results (Intersect).
            </summary>
        </member>
        <member name="M:LiteDB.Query.Or(LiteDB.Query,LiteDB.Query)">
            <summary>
            Returns documents that exists in ANY queries results (Union).
            </summary>
        </member>
        <member name="M:LiteDB.Query.ExecuteIndex(LiteDB.IndexService,LiteDB.CollectionIndex)">
            <summary>
            Abstract method that must be implement for index seek/scan - Returns IndexNodes that match with index
            </summary>
        </member>
        <member name="M:LiteDB.Query.Run(LiteDB.CollectionPage,LiteDB.IndexService)">
            <summary>
            Find witch index will be used and run Execute method
            </summary>
        </member>
        <member name="T:LiteDB.QueryAll">
            <summary>
            All is an Index Scan operation
            </summary>
        </member>
        <member name="T:LiteDB.QueryContains">
            <summary>
            Contains query do not work with index, only full scan
            </summary>
        </member>
        <member name="T:LiteDB.QueryEmpty">
            <summary>
            Placeholder query for returning no values from a collection.
            </summary>
        </member>
        <member name="M:LiteDB.QueryEmpty.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LiteDB.QueryEmpty" /> class.
            </summary>
        </member>
        <member name="T:LiteDB.QueryNotEquals">
            <summary>
            Not is an Index Scan operation
            </summary>
        </member>
        <member name="T:LiteDB.QueryWhere">
            <summary>
            Execute an index scan passing a Func as where
            </summary>
        </member>
        <member name="T:LiteDB.QueryNot">
            <summary>
            Not is an Index Scan operation
            </summary>
        </member>
        <member name="T:LiteDB.LockService">
            <summary>
            Implement a locker service locking datafile to shared/reserved and exclusive access mode
            Implement both thread lock and process lock
            Shared -> Reserved -> Exclusive => !Reserved => !Shared
            Reserved -> Exclusive => !Reserved
            [Thread Safe]
            </summary>
        </member>
        <member name="P:LiteDB.LockService.State">
            <summary>
            Get current datafile lock state
            </summary>
        </member>
        <member name="M:LiteDB.LockService.Shared">
            <summary>
            Enter in Shared lock mode.
            </summary>
        </member>
        <member name="M:LiteDB.LockService.Reserved">
            <summary>
            Enter in Reserved lock mode.
            </summary>
        </member>
        <member name="M:LiteDB.LockService.Exclusive">
            <summary>
            Enter in Exclusive lock mode
            </summary>
        </member>
        <member name="M:LiteDB.LockService.LockShared">
            <summary>
            Try enter in shared lock (read) - Call action if request a new lock
            [Non ThreadSafe]
            </summary>
        </member>
        <member name="M:LiteDB.LockService.LockReserved">
            <summary>
            Try enter in reserved mode (read - single reserved)
            [ThreadSafe] (always inside an Write())
            </summary>
        </member>
        <member name="M:LiteDB.LockService.LockExclusive">
            <summary>
            Try enter in exclusive mode (single write)
            [ThreadSafe] - always inside Reserved() -> Write() 
            </summary>
        </member>
        <member name="M:LiteDB.LockService.ThreadRead">
            <summary>
            Start new shared read lock control using timeout
            </summary>
        </member>
        <member name="M:LiteDB.LockService.ThreadWrite">
            <summary>
            Start new exclusive write lock control using timeout
            </summary>
        </member>
        <member name="M:LiteDB.LockService.AvoidDirtyRead">
            <summary>
            Test if cache still valid (if datafile was changed by another process reset cache)
            [Thread Safe]
            </summary>
        </member>
        <member name="F:LiteDB.CacheService._clean">
            <summary>
            Collection to store clean only pages in cache
            </summary>
        </member>
        <member name="F:LiteDB.CacheService._dirty">
            <summary>
            Collection to store dirty only pages in cache. If page was in _clean, remove from there and insert here
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.GetPage(System.UInt32)">
            <summary>
            Get a page from cache or from disk (and put on cache)
            [ThreadSafe]
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.AddPage(LiteDB.BasePage)">
            <summary>
            Add page to cache
            [ThreadSafe]
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.SetDirty(LiteDB.BasePage)">
            <summary>
            Set a page as dirty and ensure page are in cache. Should be used after any change on page 
            Do not use on end of method because page can be deleted/change type
            Always remove from clean list and add in dirty list
            [ThreadSafe]
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.GetDirtyPages">
            <summary>
            Return all dirty pages
            [ThreadSafe]
            </summary>
        </member>
        <member name="P:LiteDB.CacheService.CleanUsed">
            <summary>
            Get how many pages are in clean cache
            </summary>
        </member>
        <member name="P:LiteDB.CacheService.DirtyUsed">
            <summary>
            Get how many pages are in dirty cache
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.DiscardDirtyPages">
            <summary>
            Discard only dirty pages
            [ThreadSafe]
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.MarkDirtyAsClean">
            <summary>
            Mark all dirty pages now as clean pages and transfer to clean collection
            [ThreadSafe]
            </summary>
        </member>
        <member name="M:LiteDB.CacheService.ClearPages">
            <summary>
            Remove from cache all clean pages
            [Non - ThreadSafe]
            </summary>
        </member>
        <member name="M:LiteDB.CollectionService.Get(System.String)">
            <summary>
            Get a exist collection. Returns null if not exists
            </summary>
        </member>
        <member name="M:LiteDB.CollectionService.Add(System.String)">
            <summary>
            Add a new collection. Check if name the not exists
            </summary>
        </member>
        <member name="M:LiteDB.CollectionService.GetAll">
            <summary>
            Get all collections pages
            </summary>
        </member>
        <member name="M:LiteDB.CollectionService.Drop(LiteDB.CollectionPage)">
            <summary>
            Drop a collection - remove all data pages + indexes pages
            </summary>
        </member>
        <member name="M:LiteDB.DataService.Insert(LiteDB.CollectionPage,System.Byte[])">
            <summary>
            Insert data inside a datapage. Returns dataPageID that indicates the first page
            </summary>
        </member>
        <member name="M:LiteDB.DataService.Update(LiteDB.CollectionPage,LiteDB.PageAddress,System.Byte[])">
            <summary>
            Update data inside a datapage. If new data can be used in same datapage, just update. Otherwise, copy content to a new ExtendedPage
            </summary>
        </member>
        <member name="M:LiteDB.DataService.Read(LiteDB.PageAddress)">
            <summary>
            Read all data from datafile using a pageID as reference. If data is not in DataPage, read from ExtendPage.
            </summary>
        </member>
        <member name="M:LiteDB.DataService.GetBlock(LiteDB.PageAddress)">
            <summary>
            Get a data block from a DataPage using address
            </summary>
        </member>
        <member name="M:LiteDB.DataService.ReadExtendData(System.UInt32)">
            <summary>
            Read all data from a extended page with all subsequences pages if exits
            </summary>
        </member>
        <member name="M:LiteDB.DataService.Delete(LiteDB.CollectionPage,LiteDB.PageAddress)">
            <summary>
            Delete one dataBlock
            </summary>
        </member>
        <member name="M:LiteDB.DataService.StoreExtendData(LiteDB.ExtendPage,System.Byte[])">
            <summary>
            Store all bytes in one extended page. If data ir bigger than a page, store in more pages and make all in sequence
            </summary>
        </member>
        <member name="T:LiteDB.IndexService">
            <summary>
            Implement a Index service - Add/Remove index nodes on SkipList
            Based on: http://igoro.com/archive/skip-lists-are-fascinating/
            </summary>
        </member>
        <member name="F:LiteDB.IndexService.MAX_INDEX_LENGTH">
            <summary>
            Max size of a index entry - usde for string, binary, array and documents
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.CreateIndex(LiteDB.CollectionPage)">
            <summary>
            Create a new index and returns head page address (skip list)
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.AddNode(LiteDB.CollectionIndex,LiteDB.BsonValue,LiteDB.IndexNode)">
            <summary>
            Insert a new node index inside an collection index. Flip coin to know level
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.AddNode(LiteDB.CollectionIndex,LiteDB.BsonValue,System.Byte,LiteDB.IndexNode)">
            <summary>
            Insert a new node index inside an collection index.
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.GetNodeList(LiteDB.IndexNode,System.Boolean)">
            <summary>
            Gets all node list from any index node (go forward and backward)
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.Delete(LiteDB.CollectionIndex,LiteDB.PageAddress)">
            <summary>
            Deletes an indexNode from a Index and adjust Next/Prev nodes
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.DropIndex(LiteDB.CollectionIndex)">
            <summary>
            Drop all indexes pages. Each index use a single page sequence
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.GetNode(LiteDB.PageAddress)">
            <summary>
            Get a node inside a page using PageAddress - Returns null if address IsEmpty
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.FlipCoin">
            <summary>
            Flip coin - skip list - returns level node (start in 1)
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.Find(LiteDB.CollectionIndex,LiteDB.BsonValue,System.Boolean,System.Int32)">
            <summary>
            Find first node that index match with value. If not found but sibling = true, returns near node (only non-unique index)
            Before find, value must be normalized
            </summary>
        </member>
        <member name="M:LiteDB.IndexService.FindBoundary(LiteDB.CollectionIndex,LiteDB.IndexNode,LiteDB.BsonValue,System.Int32,System.Int32)">
            <summary>
            Goto the first/last occurrence of this index value
            </summary>
        </member>
        <member name="M:LiteDB.PageService.GetPage``1(System.UInt32)">
            <summary>
            Get a page from cache or from disk (get from cache or from disk)
            </summary>
        </member>
        <member name="M:LiteDB.PageService.SetDirty(LiteDB.BasePage)">
            <summary>
            Set a page as dirty and ensure page are in cache. Should be used after any change on page 
            Do not use on end of method because page can be deleted/change type
            </summary>
        </member>
        <member name="M:LiteDB.PageService.GetSeqPages``1(System.UInt32)">
            <summary>
            Read all sequences pages from a start pageID (using NextPageID)
            </summary>
        </member>
        <member name="M:LiteDB.PageService.NewPage``1(LiteDB.BasePage)">
            <summary>
            Get a new empty page - can be a reused page (EmptyPage) or a clean one (extend datafile)
            </summary>
        </member>
        <member name="M:LiteDB.PageService.DeletePage(System.UInt32,System.Boolean)">
            <summary>
            Delete an page using pageID - transform them in Empty Page and add to EmptyPageList
            If you delete a page, you can using same old instance of page - page will be converter to EmptyPage
            If need deleted page, use GetPage again
            </summary>
        </member>
        <member name="M:LiteDB.PageService.GetFreePage``1(System.UInt32,System.Int32)">
            <summary>
            Returns a page that contains space enough to data to insert new object - if one does not exit, creates a new page.
            </summary>
        </member>
        <member name="M:LiteDB.PageService.AddOrRemoveToFreeList(System.Boolean,LiteDB.BasePage,LiteDB.BasePage,System.UInt32@)">
            <summary>
            Add or Remove a page in a sequence
            </summary>
            <param name="add">Indicate that will add or remove from FreeList</param>
            <param name="page">Page to add or remove from FreeList</param>
            <param name="startPage">Page reference where start the header list node</param>
            <param name="fieldPageID">Field reference, from startPage</param>
        </member>
        <member name="M:LiteDB.PageService.AddToFreeList(LiteDB.BasePage,LiteDB.BasePage,System.UInt32@)">
            <summary>
            Add a page in free list in desc free size order
            </summary>
        </member>
        <member name="M:LiteDB.PageService.RemoveToFreeList(LiteDB.BasePage,LiteDB.BasePage,System.UInt32@)">
            <summary>
            Remove a page from list - the ease part
            </summary>
        </member>
        <member name="M:LiteDB.PageService.MoveToFreeList(LiteDB.BasePage,LiteDB.BasePage,System.UInt32@)">
            <summary>
            When a page is already on a list it's more efficient just move comparing with siblings
            </summary>
        </member>
        <member name="T:LiteDB.TransactionService">
            <summary>
            Manages all transactions and grantees concurrency and recovery
            </summary>
        </member>
        <member name="M:LiteDB.TransactionService.CheckPoint">
            <summary>
            Checkpoint is a safe point to clear cache pages without loose pages references.
            Is called after each document insert/update/deleted/indexed/fetch from query
            Clear only clean pages - do not clear dirty pages (transaction)
            </summary>
        </member>
        <member name="M:LiteDB.TransactionService.Commit">
            <summary>
            Save all dirty pages to disk
            </summary>
        </member>
        <member name="M:LiteDB.TransactionService.Rollback">
            <summary>
            Clear cache, discard journal file
            </summary>
        </member>
        <member name="M:LiteDB.TransactionService.Recovery">
            <summary>
            Try recovery journal file (if exists). Restore original datafile
            Journal file are NOT encrypted (even when datafile are encrypted)
            </summary>
        </member>
        <member name="F:LiteDB.CollectionIndex.INDEX_PER_COLLECTION">
            <summary>
            Total indexes per collection - it's fixed because I will used fixed arrays allocations
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.Slot">
            <summary>
            Represent slot position on index array on dataBlock/collection indexes - non-persistable
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.Field">
            <summary>
            Field name
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.Unique">
            <summary>
            Indicate if this index has distinct values only
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.HeadNode">
            <summary>
            Head page address for this index
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.TailNode">
            <summary>
            A link pointer to tail node
            </summary>
        </member>
        <member name="F:LiteDB.CollectionIndex.FreeIndexPageID">
            <summary>
            Get a reference for the free list index page - its private list per collection/index (must be a Field to be used as reference parameter)
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.IsEmpty">
            <summary>
            Returns if this index slot is empty and can be used as new index
            </summary>
        </member>
        <member name="P:LiteDB.CollectionIndex.Page">
            <summary>
            Get a reference for page
            </summary>
        </member>
        <member name="M:LiteDB.CollectionIndex.Clear">
            <summary>
            Clear all index information
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.Position">
            <summary>
            Position of this dataBlock inside a page (store only Position.Index)
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.ExtendPageID">
            <summary>
            If object is bigger than this page - use a ExtendPage (and do not use Data array)
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.Data">
            <summary>
            Data of a record - could be empty if is used in ExtedPage
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.Page">
            <summary>
            Get a reference for page
            </summary>
        </member>
        <member name="P:LiteDB.DataBlock.Length">
            <summary>
            Get length of this dataBlock (persist as ushort 2 bytes)
            </summary>
        </member>
        <member name="T:LiteDB.IndexNode">
            <summary>
            Represent a index node inside a Index Page
            </summary>
        </member>
        <member name="F:LiteDB.IndexNode.MAX_LEVEL_LENGTH">
            <summary>
            Max level used on skip list
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Position">
            <summary>
            Position of this node inside a IndexPage - Store only Position.Index
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Slot">
            <summary>
            Slot position of index in data block
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.PrevNode">
            <summary>
            Prev node in same document list index nodes
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.NextNode">
            <summary>
            Next node in same document list index nodes
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Prev">
            <summary>
            Link to prev value (used in skip lists - Prev.Length = Next.Length)
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Next">
            <summary>
            Link to next value (used in skip lists - Prev.Length = Next.Length)
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.KeyLength">
            <summary>
            Length of key - used for calculate Node size
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Key">
            <summary>
            The object value that was indexed
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.DataBlock">
            <summary>
            Reference for a datablock - the value
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Page">
            <summary>
            Get page reference
            </summary>
        </member>
        <member name="M:LiteDB.IndexNode.NextPrev(System.Int32,System.Int32)">
            <summary>
            Returns Next (order == 1) OR Prev (order == -1)
            </summary>
        </member>
        <member name="M:LiteDB.IndexNode.IsHeadTail(LiteDB.CollectionIndex)">
            <summary>
            Returns if this node is header or tail from collection Index
            </summary>
        </member>
        <member name="P:LiteDB.IndexNode.Length">
            <summary>
            Get the length size of this node in disk - not persistable
            </summary>
        </member>
        <member name="T:LiteDB.IndexInfo">
            <summary>
            Represent a index information
            </summary>
        </member>
        <member name="P:LiteDB.IndexInfo.Slot">
            <summary>
            Slot number of index
            </summary>
        </member>
        <member name="P:LiteDB.IndexInfo.Field">
            <summary>
            Field index name
            </summary>
        </member>
        <member name="P:LiteDB.IndexInfo.Unique">
            <summary>
            Index is Unique?
            </summary>
        </member>
        <member name="T:LiteDB.Reflection">
            <summary>
            Using Expressions is the easy and fast way to create classes, structs, get/set fields/properties. But it not works in NET35
            </summary>
            <summary>
            Helper class to get entity properties and map as BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.CreateInstance(System.Type)">
            <summary>
            Create a new instance from a Type
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.UnderlyingTypeOf(System.Type)">
            <summary>
            Get underlying get - using to get inner Type from Nullable type
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.GetListItemType(System.Type)">
            <summary>
            Get item type from a generic List or Array
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.IsList(System.Type)">
            <summary>
            Returns true if Type is any kind of Array/IList/ICollection/....
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.SelectMember(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo},System.Func{System.Reflection.MemberInfo,System.Boolean}[])">
            <summary>
            Select member from a list of member using predicate order function to select
            </summary>
        </member>
        <member name="T:LiteDB.LiteQueryable`1">
            <summary>
            An IQueryable-like class to write fluent query in LiteDB
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Include DBRef field in result query execution
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Include(System.String)">
            <summary>
            Include DBRef path in result query execution
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ForEach(System.Action{`0})">
            <summary>
            Include an action function to be executed for each entity (like ForEach in List[T])
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ForEach(System.Action{`0,System.Int32})">
            <summary>
            Include an action function to be executed for each entity (like ForEach in List[T]). Int parameter is index
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(LiteDB.Query)">
            <summary>
            Add new Query filter when query will be executed. This filter use database index
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Add new Query filter when query will be executed. This filter use database index
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(System.Boolean,LiteDB.Query)">
            <summary>
            Add new Query filter when query will be executed only with "condition" is true. This filter use database index
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(System.Boolean,System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Add new Query filter when query will be executed only with "condition" is true. This filter use database index
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Skip(System.Int32)">
            <summary>
            Skip N results before starts returing entities
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Limit(System.Int32)">
            <summary>
            Limit (Take) results 
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.SingleById(LiteDB.BsonValue)">
            <summary>
            Return entity by _id key. Throws InvalidOperationException if no document
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ToEnumerable">
            <summary>
            Execute query returning IEnumerable results.
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ToList">
            <summary>
            Execute query and return results as a List
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ToArray">
            <summary>
            Execute query and return results as an Array
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Count">
            <summary>
            Execute Count methos in filter query
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Exists">
            <summary>
            Returns true/false if filter returns any result
            </summary>
        </member>
        <member name="T:LiteDB.LiteRepository">
            <summary>
            The LiteDB repository pattern. A simple way to access your documents in a single class with fluent query api
            </summary>
        </member>
        <member name="P:LiteDB.LiteRepository.Database">
            <summary>
            Get database instance
            </summary>
        </member>
        <member name="P:LiteDB.LiteRepository.Engine">
            <summary>
            Get engine instance
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.#ctor(System.String,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using a connection string for file system database
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.#ctor(LiteDB.ConnectionString,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using a connection string for file system database
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.#ctor(System.IO.Stream,LiteDB.BsonMapper,System.String)">
            <summary>
            Starts LiteDB database using a Stream disk
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.BeginTrans">
            <summary>
            Starts new transaction. Don't forgot execute ".Commit()" method from LiteTransaction
            </summary>
        </member>
        <member name="P:LiteDB.LiteRepository.FileStorage">
            <summary>
            Returns a special collection for storage files/stream inside datafile
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Insert``1(``0,System.String)">
            <summary>
            Insert a new document into collection. Document Id must be a new value in collection - Returns document Id
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Insert``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Insert an array of new documents into collection. Document Id must be a new value in collection. Can be set buffer size to commit at each N documents
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Update``1(``0,System.String)">
            <summary>
            Update a document into collection. Returns false if not found document in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Update``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Update all documents
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Upsert``1(``0,System.String)">
            <summary>
            Insert or Update a document based on _id key. Returns true if insert entity or false if update entity
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Upsert``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Insert or Update all documents based on _id key. Returns entity count that was inserted
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Delete``1(LiteDB.BsonValue,System.String)">
            <summary>
            Delete entity based on _id key
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Delete``1(LiteDB.Query,System.String)">
            <summary>
            Delete entity based on Query
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Delete``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Delete entity based on predicate filter expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Query``1(System.String)">
            <summary>
            Returns new instance of LiteQueryable that provides all method to query any entity inside collection. Use fluent API to apply filter/includes an than run any execute command, like ToList() or First()
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.SingleById``1(LiteDB.BsonValue,System.String)">
            <summary>
            Search for a single instance of T by Id. Shortcut from Query.SingleById
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Fetch``1(LiteDB.Query,System.String)">
            <summary>
            Execute Query[T].Where(query).ToList();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Fetch``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Execute Query[T].Where(query).ToList();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.First``1(LiteDB.Query,System.String)">
            <summary>
            Execute Query[T].Where(query).First();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.First``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Execute Query[T].Where(query).First();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.FirstOrDefault``1(LiteDB.Query,System.String)">
            <summary>
            Execute Query[T].Where(query).FirstOrDefault();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.FirstOrDefault``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Execute Query[T].Where(query).FirstOrDefault();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Single``1(LiteDB.Query,System.String)">
            <summary>
            Execute Query[T].Where(query).Single();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Single``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Execute Query[T].Where(query).Single();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.SingleOrDefault``1(LiteDB.Query,System.String)">
            <summary>
            Execute Query[T].Where(query).SingleOrDefault();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.SingleOrDefault``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Execute Query[T].Where(query).SingleOrDefault();
            </summary>
        </member>
        <member name="T:LiteDB.LockControl">
            <summary>
            A class to control locking disposal. Can be a "new lock" - when a lock is not not coming from other lock state
            </summary>
        </member>
        <member name="T:LiteDB.LockState">
            <summary>
            Used to control lock state. Based on SQLite
            http://www.sqlite.org/lockingv3.html
            </summary>
        </member>
        <member name="F:LiteDB.LockState.Unlocked">
            <summary>
            No lock - initial state
            </summary>
        </member>
        <member name="F:LiteDB.LockState.Shared">
            <summary>
            FileAccess.Read | FileShared.ReadWrite
            </summary>
        </member>
        <member name="F:LiteDB.LockState.Reserved">
            <summary>
            FileAccess.Write | FileShared.Read
            </summary>
        </member>
        <member name="F:LiteDB.LockState.Exclusive">
            <summary>
            FileAccess.Write | FileShared.None
            </summary>
        </member>
        <member name="T:LiteDB.BsonRefAttribute">
            <summary>
            Indicate that field are not persisted inside this document but it's a reference for another document (DbRef)
            </summary>
        </member>
        <member name="T:LiteDB.IDbReader">
            <summary>
            Interface to implement old datafile format reader. Implements V6
            </summary>
        </member>
        <member name="T:LiteDB.FileHelper">
            <summary>
            A simple file helper tool with static methods
            </summary>
        </member>
        <member name="M:LiteDB.FileHelper.GetTempFile(System.String,System.String,System.Boolean)">
            <summary>
            Create a temp filename based on original filename - checks if file exists (if exists, append counter number)
            </summary>
        </member>
        <member name="M:LiteDB.FileHelper.TryDelete(System.String)">
            <summary>
            Try delete a file that can be in use by another
            </summary>
        </member>
        <member name="M:LiteDB.FileHelper.TryExec(System.Action,System.TimeSpan)">
            <summary>
            Try execute some action while has lock exception
            </summary>
        </member>
        <member name="T:LiteDB.PageAddress">
            <summary>
            Represents a page address inside a page structure - index could be byte offset position OR index in a list (6 bytes)
            </summary>
        </member>
        <member name="F:LiteDB.PageAddress.PageID">
            <summary>
            PageID (4 bytes)
            </summary>
        </member>
        <member name="F:LiteDB.PageAddress.Index">
            <summary>
            Index inside page (2 bytes)
            </summary>
        </member>
        <member name="T:LiteDB.BsonFieldAttribute">
            <summary>
            Set a name to this property in BsonDocument
            </summary>
        </member>
        <member name="T:LiteDB.BsonIdAttribute">
            <summary>
            Indicate that property will be used as BsonDocument Id
            </summary>
        </member>
        <member name="T:LiteDB.BsonIgnoreAttribute">
            <summary>
            Indicate that property will not be persist in Bson serialization
            </summary>
        </member>
        <member name="T:LiteDB.BsonIndexAttribute">
            <summary>
            Add an index in this entity property.
            </summary>
        </member>
        <member name="P:LiteDB.AutoId.IsEmpty">
            <summary>
            Function to test if type is empty
            </summary>
        </member>
        <member name="P:LiteDB.AutoId.NewId">
            <summary>
            Function that implements how generate a new Id for this type
            </summary>
        </member>
        <member name="T:LiteDB.BsonMapper">
            <summary>
            Class that converts your entity class to/from BsonDocument
            If you prefer use a new instance of BsonMapper (not Global), be sure cache this instance for better performance
            Serialization rules:
                - Classes must be "public" with a public constructor (without parameters)
                - Properties must have public getter (can be read-only)
                - Entity class must have Id property, [ClassName]Id property or [BsonId] attribute
                - No circular references
                - Fields are not valid
                - IList, Array supports
                - IDictionary supports (Key must be a simple datatype - converted by ChangeType)
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper._entities">
            <summary>
            Mapping cache between Class/BsonDocument
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper._customSerializer">
            <summary>
            Map serializer/deserialize for custom types
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper._typeInstantiator">
            <summary>
            Type instantiator function to support IoC
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper._autoId">
            <summary>
            Map for autoId type based functions
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper.Global">
            <summary>
            Global instance used when no BsonMapper are passed in LiteDatabase ctor
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper.ResolveFieldName">
            <summary>
            A resolver name for field
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.SerializeNullValues">
            <summary>
            Indicate that mapper do not serialize null values (default false)
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.TrimWhitespace">
            <summary>
            Apply .Trim() in strings when serialize (default true)
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.EmptyStringToNull">
            <summary>
            Convert EmptyString to Null (default true)
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.IncludeFields">
            <summary>
            Get/Set that mapper must include fields (default: false)
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.IncludeNonPublic">
            <summary>
            Get/Set that mapper must include non public (private, protected and internal) (default: false)
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper.ResolveMember">
            <summary>
            A custom callback to change MemberInfo behavior when converting to MemberMapper.
            Use mapper.ResolveMember(Type entity, MemberInfo property, MemberMapper documentMappedField)
            Set FieldName to null if you want remove from mapped document
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper.ResolveCollectionName">
            <summary>
            Custom resolve name collection based on Type 
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterType``1(System.Func{``0,LiteDB.BsonValue},System.Func{LiteDB.BsonValue,``0})">
            <summary>
            Register a custom type serializer/deserialize function
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterType(System.Type,System.Func{System.Object,LiteDB.BsonValue},System.Func{LiteDB.BsonValue,System.Object})">
            <summary>
            Register a custom type serializer/deserialize function
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterAutoId``1(System.Func{``0,System.Boolean},System.Func{LiteDB.LiteEngine,System.String,``0})">
            <summary>
            Register a custom Auto Id generator function for a type
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.SetAutoId(System.Object,LiteDB.LiteEngine,System.String)">
            <summary>
            Set new Id in entity class if entity needs one
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.Entity``1">
            <summary>
            Map your entity class to BsonDocument using fluent API
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.UseCamelCase">
            <summary>
            Use lower camel case resolution for convert property names to field names
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.UseLowerCaseDelimiter(System.Char)">
            <summary>
            Uses lower camel case with delimiter to convert property names to field names
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.GetEntityMapper(System.Type)">
            <summary>
            Get property mapper between typed .NET class and BsonDocument - Cache results
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.BuildEntityMapper(System.Type)">
            <summary>
            Use this method to override how your class can be, by default, mapped from entity to Bson document.
            Returns an EntityMapper from each requested Type
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.GetIdMember(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
            <summary>
            Gets MemberInfo that refers to Id from a document object.
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.GetTypeMembers(System.Type)">
            <summary>
            Returns all member that will be have mapper between POCO class to document
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterDbRef(LiteDB.BsonMapper,LiteDB.MemberMapper,System.String)">
            <summary>
            Register a property mapper as DbRef to serialize/deserialize only document reference _id
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterDbRefItem(LiteDB.BsonMapper,LiteDB.MemberMapper,System.String)">
            <summary>
            Register a property as a DbRef - implement a custom Serialize/Deserialize actions to convert entity to $id, $ref only
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterDbRefList(LiteDB.BsonMapper,LiteDB.MemberMapper,System.String)">
            <summary>
            Register a property as a DbRefList - implement a custom Serialize/Deserialize actions to convert entity to $id, $ref only
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.ToObject(System.Type,LiteDB.BsonDocument)">
            <summary>
            Deserialize a BsonDocument to entity class
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.ToObject``1(LiteDB.BsonDocument)">
            <summary>
            Deserialize a BsonDocument to entity class
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.Deserialize``1(LiteDB.BsonValue)">
            <summary>
            Deserialize an BsonValue to .NET object typed in T
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.ToDocument(System.Type,System.Object)">
            <summary>
            Serialize a entity class to BsonDocument
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.ToDocument``1(``0)">
            <summary>
            Serialize a entity class to BsonDocument
            </summary>
        </member>
        <member name="T:LiteDB.EntityMapper">
            <summary>
            Class to map entity class to BsonDocument
            </summary>
        </member>
        <member name="P:LiteDB.EntityMapper.Members">
            <summary>
            List all type members that will be mapped to/from BsonDocument
            </summary>
        </member>
        <member name="P:LiteDB.EntityMapper.Id">
            <summary>
            Indicate which member is _id
            </summary>
        </member>
        <member name="P:LiteDB.EntityMapper.ForType">
            <summary>
            Indicate which Type this entity mapper is
            </summary>
        </member>
        <member name="M:LiteDB.EntityMapper.GetMember(System.Linq.Expressions.Expression)">
            <summary>
            Resolve expression to get member mapped
            </summary>
        </member>
        <member name="T:LiteDB.EntityBuilder`1">
            <summary>
            Helper class to modify your entity mapping to document. Can be used instead attribute decorates
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Ignore``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Define which property will not be mapped to document
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Field``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String)">
            <summary>
            Define a custom name for a property when mapping to document
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Id``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Define which property is your document id (primary key). Define if this property supports auto-id
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Index``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Define an index based in a property on entity
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Index``1(System.String,System.Func{`0,LiteDB.BsonValue},System.Boolean)">
            <summary>
            Define an index based in virtual property (getter function)
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Index(System.String,System.Boolean)">
            <summary>
            Define an index based in a field name on BsonDocument
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.DbRef``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String)">
            <summary>
            Define a subdocument (or a list of) as a reference
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.GetProperty``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Action{LiteDB.MemberMapper})">
            <summary>
            Get a property based on a expression. Eg.: 'x => x.UserId' return string "UserId"
            </summary>
        </member>
        <member name="T:LiteDB.QueryVisitor`1">
            <summary>
            Class helper to create Queries based on Linq expressions
            </summary>
        </member>
        <member name="M:LiteDB.QueryVisitor`1.GetField(System.Linq.Expressions.Expression,System.String)">
            <summary>
            Based on an expression, returns document field mapped from class Property.
            Support multi level dotted notation: x => x.Customer.Name
            Prefix is used on array expression like: x => x.Customers.Any(z => z.Name == "John") (prefix = "Customers." 
            </summary>
        </member>
        <member name="T:LiteDB.MemberMapper">
            <summary>
            Internal representation for a .NET member mapped to BsonDocument
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.AutoId">
            <summary>
            If member is Id, indicate that are AutoId
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.MemberName">
            <summary>
            Member name
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.DataType">
            <summary>
            Member returns data type
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.FieldName">
            <summary>
            Converted document field name
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.Getter">
            <summary>
            Delegate method to get value from entity instance
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.Setter">
            <summary>
            Delegate method to set value to entity instance
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.Serialize">
            <summary>
            When used, can be define a serialization function from entity class to bson value
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.Deserialize">
            <summary>
            When used, can define a deserialization function from bson value
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.IsUnique">
            <summary>
            Indicate field has an unique index
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.IsDbRef">
            <summary>
            Is this property an DbRef? Must implement Serialize/Deserialize delegates
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.IsList">
            <summary>
            Indicate that this property contains an list of elements (IEnumerable)
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.UnderlyingType">
            <summary>
            When property is an array of items, gets underlying type (otherwise is same type of PropertyType)
            </summary>
        </member>
        <member name="T:LiteDB.LiteFileInfo">
            <summary>
            Represents a file inside storage collection
            </summary>
        </member>
        <member name="F:LiteDB.LiteFileInfo.ID_PATTERN">
            <summary>
            File id have a specific format - it's like file path.
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo.OpenRead">
            <summary>
            Open file stream to read from database
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo.OpenWrite">
            <summary>
            Open file stream to write to database
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo.CopyTo(System.IO.Stream)">
            <summary>
            Copy file content to another stream
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo.SaveAs(System.String,System.Boolean)">
            <summary>
            Save file content to a external file
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStream.WriteChunks">
            <summary>
            Consume all _buffer bytes and write to database
            </summary>
        </member>
        <member name="F:LiteDB.LiteFileStream.MAX_CHUNK_SIZE">
            <summary>
            Number of bytes on each chunk document to store
            </summary>
        </member>
        <member name="P:LiteDB.LiteFileStream.FileInfo">
            <summary>
            Get file information
            </summary>
        </member>
        <member name="T:LiteDB.LiteStorage">
            <summary>
            Storage is a special collection to store files/streams. Transactions are not supported in Upload/Download operations.
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage.OpenWrite(System.String,System.String,LiteDB.BsonDocument)">
            <summary>
            Open/Create new file storage and returns linked Stream to write operations
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage.Upload(System.String,System.String,System.IO.Stream)">
            <summary>
            Upload a file based on stream data
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage.Upload(System.String,System.String)">
            <summary>
            Upload a file based on file system data
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage.SetMetadata(System.String,LiteDB.BsonDocument)">
            <summary>
            Update metadata on a file. File must exist.
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage.OpenRead(System.String)">
            <summary>
            Load data inside storage and returns as Stream
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage.Download(System.String,System.IO.Stream)">
            <summary>
            Copy all file content to a steam
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage.FindById(System.String)">
            <summary>
            Find a file inside datafile and returns FileEntry instance. Returns null if not found
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage.Find(System.String)">
            <summary>
            Returns all FileEntry founded starting with id passed.
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage.Exists(System.String)">
            <summary>
            Returns if a file exisits in database
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage.FindAll">
            <summary>
            Returns all FileEntry inside database
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage.Delete(System.String)">
            <summary>
            Delete a file inside datafile and all metadata related
            </summary>
        </member>
        <member name="T:LiteDB.ConnectionString">
            <summary>
            Manage ConnectionString to connect and create databases. Connection string are NameValue using Name1=Value1; Name2=Value2
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.Filename">
            <summary>
            "filename": Full path or relative path from DLL directory
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.Journal">
            <summary>
            "journal": Enabled or disable double write check to ensure durability (default: true)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.Password">
            <summary>
            "password": Encrypt (using AES) your datafile with a password (default: null - no encryption)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.CacheSize">
            <summary>
            "cache size": Max number of pages in cache. After this size, flush data to disk to avoid too memory usage (default: 5000)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.Timeout">
            <summary>
            "timeout": Timeout for waiting unlock operations (default: 1 minute)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.Mode">
            <summary>
            "mode": Define if datafile will be shared, exclusive or read only access (default: Shared)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.InitialSize">
            <summary>
            "initial size": If database is new, initialize with allocated space - support KB, MB, GB (default: null)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.LimitSize">
            <summary>
            "limit size": Max limit of datafile - support KB, MB, GB (default: null)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.Log">
            <summary>
            "log": Debug messages from database - use `LiteDatabase.Log` (default: Logger.NONE)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.Upgrade">
            <summary>
            "upgrade": Test if database is in old version and update if needed (default: false)
            </summary>
        </member>
        <member name="M:LiteDB.ConnectionString.#ctor">
            <summary>
            Initialize empty connection string
            </summary>
        </member>
        <member name="M:LiteDB.ConnectionString.#ctor(System.String)">
            <summary>
            Initialize connection string parsing string in "key1=value1;key2=value2;...." format or only "filename" as default (when no ; char found)
            </summary>
        </member>
        <member name="T:LiteDB.FileOptions">
            <summary>
            Datafile open options (for FileDiskService)
            </summary>
        </member>
        <member name="T:LiteDB.AesEncryption">
            <summary>
            Encryption AES wrapper to encrypt data pages
            </summary>
        </member>
        <member name="M:LiteDB.AesEncryption.Encrypt(System.Byte[])">
            <summary>
            Encrypt byte array returning new encrypted byte array with same length of original array (PAGE_SIZE)
            </summary>
        </member>
        <member name="M:LiteDB.AesEncryption.Decrypt(System.Byte[])">
            <summary>
            Decrypt and byte array returning a new byte array
            </summary>
        </member>
        <member name="M:LiteDB.AesEncryption.HashSHA1(System.String)">
            <summary>
            Hash a password using SHA1 just to verify password
            </summary>
        </member>
        <member name="M:LiteDB.AesEncryption.Salt(System.Int32)">
            <summary>
            Generate a salt key that will be stored inside first page database
            </summary>
            <returns></returns>
        </member>
        <member name="T:LiteDB.StorageUnitHelper">
            <summary>
            Parse/Format storage unit format (kb/mb/gb)
            </summary>
        </member>
        <member name="M:LiteDB.StorageUnitHelper.ParseFileSize(System.String)">
            <summary>
            Convert storage unit string "1gb", "10 mb", "80000" to long bytes
            </summary>
        </member>
        <member name="M:LiteDB.StorageUnitHelper.FormatFileSize(System.Int64)">
            <summary>
            Format a long file length to pretty file unit
            </summary>
        </member>
        <member name="T:LiteDB.BsonReader">
            <summary>
            Internal class to deserialize a byte[] into a BsonDocument using BSON data format
            </summary>
        </member>
        <member name="M:LiteDB.BsonReader.Deserialize(System.Byte[])">
            <summary>
            Main method - deserialize using ByteReader helper
            </summary>
        </member>
        <member name="M:LiteDB.BsonReader.ReadDocument(LiteDB.ByteReader)">
            <summary>
            Read a BsonDocument from reader
            </summary>
        </member>
        <member name="M:LiteDB.BsonReader.ReadArray(LiteDB.ByteReader)">
            <summary>
            Read an BsonArray from reader
            </summary>
        </member>
        <member name="M:LiteDB.BsonReader.ReadElement(LiteDB.ByteReader,System.String@)">
            <summary>
            Reads an element (key-value) from an reader
            </summary>
        </member>
        <member name="T:LiteDB.BsonSerializer">
            <summary>
            Class to call method for convert BsonDocument to/from byte[] - based on http://bsonspec.org/spec.html
            </summary>
        </member>
        <member name="T:LiteDB.BsonWriter">
            <summary>
            Internal class to serialize a BsonDocument to BSON data format (byte[])
            </summary>
        </member>
        <member name="M:LiteDB.BsonWriter.Serialize(LiteDB.BsonDocument)">
            <summary>
            Main method - serialize document. Uses ByteWriter
            </summary>
        </member>
        <member name="M:LiteDB.BsonWriter.WriteDocument(LiteDB.ByteWriter,LiteDB.BsonDocument)">
            <summary>
            Write a bson document
            </summary>
        </member>
        <member name="T:LiteDB.ObjectId">
            <summary>
            Represent a 12-bytes BSON type used in document Id
            </summary>
        </member>
        <member name="F:LiteDB.ObjectId.Empty">
            <summary>
            A zero 12-bytes ObjectId
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Timestamp">
            <summary>
            Get timestamp
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Machine">
            <summary>
            Get machine number
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Pid">
            <summary>
            Get pid number
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Increment">
            <summary>
            Get increment
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.CreationTime">
            <summary>
            Get creation time
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor">
            <summary>
            Initializes a new empty instance of the ObjectId class.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(System.Int32,System.Int32,System.Int16,System.Int32)">
            <summary>
            Initializes a new instance of the ObjectId class from ObjectId vars.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(LiteDB.ObjectId)">
            <summary>
            Initializes a new instance of ObjectId class from another ObjectId.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ObjectId class from hex string.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the ObjectId class from byte array.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.FromHex(System.String)">
            <summary>
            Convert hex value string in byte array
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.Equals(LiteDB.ObjectId)">
            <summary>
            Checks if this ObjectId is equal to the given object. Returns true
            if the given object is equal to the value of this instance. 
            Returns false otherwise.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to this instance.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.CompareTo(LiteDB.ObjectId)">
            <summary>
            Compares two instances of ObjectId
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.ToByteArray">
            <summary>
            Represent ObjectId as 12 bytes array
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.NewObjectId">
            <summary>
            Creates a new ObjectId.
            </summary>
        </member>
        <member name="T:LiteDB.JsonReader">
            <summary>
            A class that read a json string using a tokenizer (without regex)
            </summary>
        </member>
        <member name="T:LiteDB.JsonTokenizer">
            <summary>
            Class that parse a json string and returns in json token
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.Read">
            <summary>
            Read next char in stream and set in _current
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.ReadToken">
            <summary>
            Read next json token
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.EatWhitespace">
            <summary>
            Eat all whitespace - used before a valid token
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.ReadWord">
            <summary>
            Read a word without "
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.ReadNumber">
            <summary>
            Read a number - it's accepts all number char, but not validate. When run Convert, .NET will check if number is correct
            </summary>
        </member>
        <member name="M:LiteDB.JsonTokenizer.ReadString">
            <summary>
            Read a string removing open and close "
            </summary>
        </member>
        <member name="T:LiteDB.BsonValue">
            <summary>
            Represent a Bson Value used in BsonDocument
            </summary>
        </member>
        <member name="F:LiteDB.BsonValue.Null">
            <summary>
            Represent a Null bson type
            </summary>
        </member>
        <member name="F:LiteDB.BsonValue.MinValue">
            <summary>
            Represent a MinValue bson type
            </summary>
        </member>
        <member name="F:LiteDB.BsonValue.MaxValue">
            <summary>
            Represent a MaxValue bson type
            </summary>
        </member>
        <member name="P:LiteDB.BsonValue.Type">
            <summary>
            Indicate BsonType of this BsonValue
            </summary>
        </member>
        <member name="P:LiteDB.BsonValue.RawValue">
            <summary>
            Get internal .NET value object
            </summary>
        </member>
        <member name="M:LiteDB.BsonValue.GetBytesCount(System.Boolean)">
            <summary>
            Returns how many bytes this BsonValue will use to persist in index writes
            </summary>
        </member>
        <member name="T:LiteDB.BsonType">
            <summary>
            All supported BsonTypes in sort order
            </summary>
        </member>
        <member name="P:LiteDB.BsonDocument.Item(System.String)">
            <summary>
            Get/Set a field for document. Fields are case sensitive
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.IsValidFieldName(System.String)">
            <summary>
            Test if field name is a valid string: only [\w$]+(\w-$)*
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.Get(System.String)">
            <summary>
            Get value from a path - supports dotted path like: Customer.Address.Street
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.Set(System.String,LiteDB.BsonValue)">
            <summary>
            Set value to a path - supports dotted path like: Customer.Address.Street - Fluent API (returns same BsonDocument)
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.GetValues(System.String,System.Boolean,System.Boolean)">
            <summary>
            Get a collection of values from a path. Supports array values. If SingleValue=true, returns BsonArray as a single value (BsonArray)
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.GetKeyValues(LiteDB.BsonValue,System.String)">
            <summary>
            Get, recursivly, values inside a BsonValue respecting Arrays and Documents path
            </summary>
        </member>
        <member name="T:LiteDB.JsonSerializer">
            <summary>
            Static class for serialize/deserialize BsonDocuments into json extended format
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Serialize(LiteDB.BsonValue,System.Boolean,System.Boolean)">
            <summary>
            Json serialize a BsonValue into a String
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Serialize(LiteDB.BsonValue,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Json serialize a BsonValue into a TextWriter
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Deserialize(System.String)">
            <summary>
            Deserialize a Json string into a BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Deserialize(System.IO.TextReader)">
            <summary>
            Deserialize a Json TextReader into a BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Deserialize(LiteDB.StringScanner)">
            <summary>
            Deserialize a json using a StringScanner and returns BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.DeserializeArray(System.String)">
            <summary>
            Deserialize a json array as an IEnumerable of BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.DeserializeArray(System.IO.TextReader)">
            <summary>
            Deserialize a json array as an IEnumerable of BsonValue reading on demand TextReader
            </summary>
        </member>
        <member name="T:LiteDB.LazyLoad`1">
            <summary>
            LazyLoad class for .NET 3.5
            http://stackoverflow.com/questions/3207580/implementation-of-lazyt-for-net-3-5
            </summary>
        </member>
        <member name="P:LiteDB.LazyLoad`1.Value">
            <summary>
            Gets the lazily initialized value of the current Lazy{T} instance.
            </summary>
        </member>
        <member name="P:LiteDB.LazyLoad`1.IsValueCreated">
            <summary>
            Gets a value that indicates whether a value has been created for this Lazy{T} instance.
            </summary>
        </member>
        <member name="M:LiteDB.LazyLoad`1.#ctor(System.Func{`0})">
            <summary>
            Initializes a new instance of the Lazy{T} class.
            </summary>
            <param name="createValue">The delegate that produces the value when it is needed.</param>
        </member>
        <member name="M:LiteDB.LazyLoad`1.ToString">
            <summary>
            Creates and returns a string representation of the Lazy{T}.Value.
            </summary>
            <returns>The string representation of the Lazy{T}.Value property.</returns>
        </member>
        <member name="M:LiteDB.ExpressionExtensions.GetPath(System.Linq.Expressions.Expression)">
            <summary>
            Get Path (better ToString) from an Expression.
            Support multi levels: x => x.Customer.Address
            Support list levels: x => x.Addresses.Select(z => z.StreetName)
            </summary>
        </member>
        <member name="M:LiteDB.StreamExtensions.TryUnlock(System.IO.FileStream,System.Int64,System.Int64)">
            <summary>
            Try unlock stream segment. Do nothing if was not possible (it's not locked)
            </summary>
        </member>
        <member name="M:LiteDB.StreamExtensions.TryLock(System.IO.FileStream,System.Int64,System.Int64,System.TimeSpan)">
            <summary>
            Try lock a stream segment during timeout.
            </summary>
        </member>
        <member name="M:LiteDB.IOExceptionExtensions.IsLocked(System.IO.IOException)">
            <summary>
            Detect if exception is an Locked exception
            </summary>
        </member>
        <member name="M:LiteDB.IOExceptionExtensions.WaitFor(System.Int32)">
            <summary>
            WaitFor function used in NETFULL + PCL
            </summary>
        </member>
        <member name="T:LiteDB.MimeTypeConverter">
            <summary>
            Convert filename to mimetype (http://stackoverflow.com/questions/1029740/get-mime-type-from-filename-extension)
            </summary>
        </member>
        <member name="M:LiteDB.DictionaryExtensions.GetValue``1(System.Collections.Generic.Dictionary{System.String,System.String},System.String,``0)">
            <summary>
            Get value from dictionary converting datatype T
            </summary>
        </member>
        <member name="M:LiteDB.DictionaryExtensions.GetFileSize(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Int64)">
            <summary>
            Get a value from a key converted in file size format: "1gb", "10 mb", "80000"
            </summary>
        </member>
        <member name="T:LiteDB.LiteException">
            <summary>
            The main exception for LiteDB
            </summary>
        </member>
        <member name="T:LiteDB.Logger">
            <summary>
            A logger class to log all information about database. Used with levels. Level = 0 - 255
            All log will be trigger before operation execute (better for debug)
            </summary>
        </member>
        <member name="M:LiteDB.Logger.#ctor(System.Byte,System.Action{System.String})">
            <summary>
            Initialize logger class using a custom logging level (see Logger.NONE to Logger.FULL)
            </summary>
        </member>
        <member name="E:LiteDB.Logger.Logging">
            <summary>
            Event when log writes a message. Fire on each log message
            </summary>
        </member>
        <member name="P:LiteDB.Logger.Level">
            <summary>
            To full logger use Logger.FULL or any combination of Logger constants like Level = Logger.ERROR | Logger.COMMAND | Logger.DISK
            </summary>
        </member>
        <member name="M:LiteDB.Logger.Write(System.Byte,System.String,System.Object[])">
            <summary>
            Write log text to output using inside a component (statics const of Logger)
            </summary>
        </member>
        <member name="T:LiteDB.StringScanner">
            <summary>
            A StringScanner is state machine used in text parsers based on regular expressions
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.#ctor(System.String)">
            <summary>
            Initialize scanner with a string to be parsed
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Reset">
            <summary>
            Reset cursor position
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Seek(System.Int32)">
            <summary>
            Skip cursor position in string source
            </summary>
        </member>
        <member name="P:LiteDB.StringScanner.HasTerminated">
            <summary>
            Indicate that cursor is EOF
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Scan(System.String)">
            <summary>
            Scan in current cursor position for this patterns. If found, returns string and run with cursor
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Scan(System.Text.RegularExpressions.Regex)">
            <summary>
            Scan in current cursor position for this patterns. If found, returns string and run with cursor
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Scan(System.String,System.Int32)">
            <summary>
            Scan pattern and returns group string index 1 based
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Match(System.String)">
            <summary>
            Match if pattern is true in current cursor position. Do not change cursor position
            </summary>
        </member>
        <member name="M:LiteDB.StringScanner.Match(System.Text.RegularExpressions.Regex)">
            <summary>
            Match if pattern is true in current cursor position. Do not change cursor position
            </summary>
        </member>
        <member name="M:LiteDB_V6.DbReader.Initialize(System.IO.Stream,System.String)">
            <summary>
            Initialize database reader with database stream file and password
            </summary>
        </member>
        <member name="M:LiteDB_V6.DbReader.GetCollections">
            <summary>
            Get all collections names from header
            </summary>
        </member>
        <member name="M:LiteDB_V6.DbReader.GetUniqueIndexes(System.String)">
            <summary>
            List all unique indexes (excluding _id index)
            </summary>
        </member>
        <member name="M:LiteDB_V6.DbReader.GetDocuments(System.String)">
            <summary>
            List all documents inside an collections. Use PK to get all documents in order
            </summary>
        </member>
        <member name="M:LiteDB_V6.BasePage.CreateInstance(System.UInt32,LiteDB_V6.PageType)">
            <summary>
            Create a new instance of page based on PageType
            </summary>
        </member>
        <member name="M:LiteDB_V6.BasePage.ReadPage(System.Byte[])">
            <summary>
            Read a page with correct instance page object. Checks for pageType
            </summary>
        </member>
        <member name="T:LiteDB_V6.CollectionPage">
            <summary>
            Represents the collection page AND a collection item, because CollectionPage represent a Collection (1 page = 1 collection). All collections pages are linked with Prev/Next links
            </summary>
        </member>
        <member name="P:LiteDB_V6.CollectionPage.PK">
            <summary>
            Get primary key index (_id index)
            </summary>
        </member>
        <member name="T:LiteDB_V6.DataPage">
            <summary>
            The DataPage thats stores object data.
            </summary>
        </member>
        <member name="T:LiteDB_V6.ExtendPage">
            <summary>
            Represent a extra data page that contains the object when is not possible store in DataPage (bigger then  PAGE_SIZE or on update has no more space on page)
            Can be used in sequence of pages to store big objects
            </summary>
        </member>
        <member name="M:LiteDB_V6.IndexPage.ReadBsonValue(LiteDB.ByteReader,System.UInt16)">
            <summary>
            Write a custom ReadBsonValue because BsonType changed from v6 to v7
            </summary>
        </member>
        <member name="M:LiteDB_V6.CollectionService.Get(System.String)">
            <summary>
            Get a exist collection. Returns null if not exists
            </summary>
        </member>
        <member name="M:LiteDB_V6.DataService.Read(LiteDB.PageAddress)">
            <summary>
            Read all data from datafile using a pageID as reference. If data is not in DataPage, read from ExtendPage.
            </summary>
        </member>
        <member name="M:LiteDB_V6.DataService.GetBlock(LiteDB.PageAddress)">
            <summary>
            Get a data block from a DataPage using address
            </summary>
        </member>
        <member name="M:LiteDB_V6.DataService.ReadExtendData(System.UInt32)">
            <summary>
            Read all data from a extended page with all subsequences pages if exits
            </summary>
        </member>
        <member name="T:LiteDB_V6.FileDiskService">
            <summary>
            Implement NTFS File disk
            </summary>
        </member>
        <member name="F:LiteDB_V6.FileDiskService.PAGE_TYPE_POSITION">
            <summary>
            Position, on page, about page type
            </summary>
        </member>
        <member name="M:LiteDB_V6.FileDiskService.ReadPage(System.UInt32)">
            <summary>
            Read page bytes from disk
            </summary>
        </member>
        <member name="T:LiteDB_V6.IndexService">
            <summary>
            Implement a Index service - Add/Remove index nodes on SkipList
            </summary>
        </member>
        <member name="M:LiteDB_V6.IndexService.GetNode(LiteDB.PageAddress)">
            <summary>
            Get a node inside a page using PageAddress - Returns null if address IsEmpty
            </summary>
        </member>
        <member name="M:LiteDB_V6.PageService.GetPage``1(System.UInt32)">
            <summary>
            Get a page from cache or from disk (and put on cache)
            </summary>
        </member>
        <member name="M:LiteDB_V6.PageService.GetSeqPages``1(System.UInt32)">
            <summary>
            Read all sequences pages from a start pageID (using NextPageID)
            </summary>
        </member>
        <member name="F:LiteDB_V6.CollectionIndex.INDEX_PER_COLLECTION">
            <summary>
            Total indexes per collection - it's fixed because I will used fixed arrays allocations
            </summary>
        </member>
        <member name="P:LiteDB_V6.CollectionIndex.Slot">
            <summary>
            Represent slot position on index array on dataBlock/collection indexes - non-persistable
            </summary>
        </member>
        <member name="P:LiteDB_V6.CollectionIndex.Field">
            <summary>
            Field name
            </summary>
        </member>
        <member name="P:LiteDB_V6.CollectionIndex.Unique">
            <summary>
            Unique index
            </summary>
        </member>
        <member name="P:LiteDB_V6.CollectionIndex.HeadNode">
            <summary>
            Head page address for this index
            </summary>
        </member>
        <member name="P:LiteDB_V6.CollectionIndex.TailNode">
            <summary>
            A link pointer to tail node
            </summary>
        </member>
        <member name="F:LiteDB_V6.CollectionIndex.FreeIndexPageID">
            <summary>
            Get a reference for the free list index page - its private list per collection/index (must be a Field to be used as reference parameter)
            </summary>
        </member>
        <member name="P:LiteDB_V6.CollectionIndex.Page">
            <summary>
            Get a reference for page
            </summary>
        </member>
        <member name="P:LiteDB_V6.DataBlock.Position">
            <summary>
            Position of this dataBlock inside a page (store only Position.Index)
            </summary>
        </member>
        <member name="P:LiteDB_V6.DataBlock.IndexRef">
            <summary>
            Indexes nodes for all indexes for this data block
            </summary>
        </member>
        <member name="P:LiteDB_V6.DataBlock.ExtendPageID">
            <summary>
            If object is bigger than this page - use a ExtendPage (and do not use Data array)
            </summary>
        </member>
        <member name="P:LiteDB_V6.DataBlock.Data">
            <summary>
            Data of a record - could be empty if is used in ExtedPage
            </summary>
        </member>
        <member name="P:LiteDB_V6.DataBlock.Page">
            <summary>
            Get a reference for page
            </summary>
        </member>
        <member name="T:LiteDB_V6.IndexNode">
            <summary>
            Represent a index node inside a Index Page
            </summary>
        </member>
        <member name="P:LiteDB_V6.IndexNode.Position">
            <summary>
            Position of this node inside a IndexPage - Store only Position.Index
            </summary>
        </member>
        <member name="P:LiteDB_V6.IndexNode.Prev">
            <summary>
            Pointer to prev value (used in skip lists - Prev.Length = Next.Length)
            </summary>
        </member>
        <member name="P:LiteDB_V6.IndexNode.Next">
            <summary>
            Pointer to next value (used in skip lists - Prev.Length = Next.Length)
            </summary>
        </member>
        <member name="P:LiteDB_V6.IndexNode.KeyLength">
            <summary>
            Length of key - used for calculate Node size
            </summary>
        </member>
        <member name="P:LiteDB_V6.IndexNode.Key">
            <summary>
            The object value that was indexed
            </summary>
        </member>
        <member name="P:LiteDB_V6.IndexNode.DataBlock">
            <summary>
            Reference for a datablock - the value
            </summary>
        </member>
        <member name="P:LiteDB_V6.IndexNode.Page">
            <summary>
            Get page reference
            </summary>
        </member>
        <member name="M:LiteDB_V6.IndexNode.IsHeadTail(LiteDB_V6.CollectionIndex)">
            <summary>
            Returns if this node is header or tail from collection Index
            </summary>
        </member>
        <member name="T:LiteDB_V6.RijndaelEncryption">
            <summary>
            Simple Rijndael wrapper to encrypt data pages (based in http://stackoverflow.com/questions/165808/simple-two-way-encryption-for-c-sharp)
            </summary>
        </member>
        <member name="M:LiteDB_V6.RijndaelEncryption.Decrypt(System.Byte[])">
            <summary>
            Decrypt and byte array returning a new byte array
            </summary>
        </member>
        <member name="M:LiteDB_V6.RijndaelEncryption.HashSHA1(System.String)">
            <summary>
            Hash a password using SHA1 just to verify password
            </summary>
        </member>
    </members>
</doc>
